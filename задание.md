# Домашнее задание

**Дисциплина:** Язык Java  
**Тема:** Инструменты разработчика  
**Форма проверки:** Самопроверка. Студент выполняет задание и самостоятельно проверяет его

**Имя преподавателя:** Артур Домбровский  
**Время выполнения:** 6 часов

## Цель задания

Научиться:

- настраивать сборку Java-приложения с помощью Gradle;
- использовать дебаггер IntelliJ IDEA для анализа выполнения кода и поиска ошибок;
- работать с профилировщиком;
- формировать выводы о производительности и оптимизации кода на основе метрик CPU.

## Инструменты для выполнения ДЗ

Java 17+, Spring Boot, Gradle, curl или httpie, IntelliJ IDEA Debugger, Java Flight Recorder или IntelliJ IDEA Ultimate Profiler, IntelliJ IDEA, GitHub или другой подобный веб-сервис для хостинга IT-проектов и их совместной разработки

## Правила приема работы

Прикрепите ссылку на выполненное задание в GitHub. По ссылке должны быть доступны файлы исходного кода приложения.

## Критерии оценки

**Задание считается выполненным, если:**

- прикреплена ссылка на репозиторий в GitHub с выполненным заданием, соответствующим правилам приёма работы;
- доступ к репозиторию открыт;
- код программы написан на Java и соответствует всем требованиям задания;
- программа компилируется и запускается.

**Задание не выполнено, если:**

- ссылка на репозиторий с заданием не прикреплена или отсутствует доступ по ссылке;
- репозиторий с заданием пуст или содержит материалы, не соответствующие правилам приёма работы и требованиям задания;
- программа не компилируется или не запускается.

**Дедлайн:** Срок сдачи — 7 дней после даты соответствующего вебинара

---

## Задание 1. Сборка проекта с Gradle

### Этап 1. Базовая работа с Gradle

Создайте файл `build.gradle`. Используйте Gradle Plugin для сборки проекта.
Команда `./gradlew bootRun` должна запускать проект.

### Этап 2. Создание кастомной задачи (custom task)

Создайте в файле `build.gradle` новую задачу (task), например, `runTestDataInitializer`. Эта задача должна выполнять команду, которая с помощью curl или httpie отправляет POST-запрос на эндпоинт `/api/messages`, чтобы быстро заполнить базу данных тестовыми сообщениями.

### Этап 3. Управление зависимостями (dependency management)

Перенесите все зависимости, связанные с Hibernate/JPA, в отдельный конфигурационный блок (например, в начало файла), используя переменные для версий.
Используйте Gradle Wrapper для гарантированного запуска проекта (`./gradlew build`).

---

## Задание 2. Отладка приложения: дебаггер (IntelliJ IDEA Debugger)

Необходимо провести отладку приложения. Используйте в качестве объекта для дебаггинга проблемные сценарии из домашнего задания 6: проблема N+1 и LazyInitializationException.

### Этап 1. Работа с дебаггером в режиме пошагового выполнения (step-by-step execution)

- Установите точку останова (breakpoint) в методе `MessageService.getMessagesOptimized()`.
- Запустите приложение в режиме Debug.
- Используйте команды Step Into (F7) и Step Over (F8), чтобы проследить, как запрос попадает из контроллера в сервис, а затем в репозиторий.

### Этап 2. Проверка состояния: панели Variables и Watches (переменные и выражения)

- В методе, который вызывает проблему N+1, остановитесь на точке останова.
- Используйте панели Variables или Watches, чтобы увидеть, какие поля сущности Message уже загружены (имеют данные), а какие являются прокси-объектами (например, author), что является причиной N+1.
- Создайте условную точку останова, которая сработает только тогда, когда `message.getId()` будет равен, например, 5.

### Этап 3. Имитация исключения (exception simulation)

- Установите точку останова в методе `MessageService.getMessageToFail(id)`.
- Используйте Evaluate Expression (Alt + F8 / Option + F8) для принудительного вызова лениво загружаемого поля (`message.getAuthor().getUsername()`) до того, как транзакция закроется, чтобы смоделировать ошибку LazyInitializationException и понять, в какой момент она возникает.

---

## Задание 3. Профилирование и интерпретация Flame Graphs (Java Flight Recorder или IntelliJ IDEA Ultimate Profiler)

Предположим, что наше приложение начинает работать медленно под нагрузкой. Необходимо провести анализ и выявить проблемные места в приложении.

### Этап 1. Подготовка

Убедитесь, что приложение запущено с достаточным количеством тестовых данных (используйте кастомную задачу Gradle из задания 1).

### Этап 2. Запуск Profiler

Запустите приложение с помощью опции Run with Profiler.

### Этап 3. Анализ CPU

- Воспроизведите нагрузку. Например: выполните 100 запросов curl к неоптимизированному эндпоинту `/api/messages/nplus1` за короткое время.
- Остановите сбор данных профилировщика.

### Этап 4. Чтение Flame Graphs

- Изучите сгенерированный Flame Graph или Call Tree.
- Определите, какая часть кода занимает наибольшее время CPU.
- Составьте краткий отчёт, сравнивающий результаты CPU-анализа для оптимизированного (`/optimized`) и неоптимизированного (`/nplus1`) эндпоинтов, используя данные из профайлера.

---

## Чек-лист самопроверки

| Критерии выполнения задания | Отметка о выполнении |
|---|---|
| Корректно настроен файл build.gradle с Gradle Plugin для Spring Boot | |
| Команда ./gradlew bootRun запускает приложение без ошибок | |
| Кастомная задача runTestDataInitializer отправляет POST-запрос и наполняет базу тестовыми сообщениями | |
| В методах установлены необходимые точки останова | |
| Смоделирована ошибка LazyInitializationException<br>• Определена причина её появления | |
| Настроен и запущен профилировщик, собраны данные по CPU | |
| Построен Flame Graph<br>• Выявлен участок кода с избыточной нагрузкой<br>• Составлен краткий отчёт, сравнивающий результаты профилирования эндпоинтов /optimized и /nplus1 | |
